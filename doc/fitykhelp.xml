<?xml version="1.0"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.2//EN' 
              'http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd'
[
<!ENTITY two-theta "
    <inlinemediaobject>
     <imageobject><imagedata fileref='fitykhelp_img/2theta.png'/></imageobject>
     <textobject><phrase>2theta</phrase></textobject>
    </inlinemediaobject> 
  ">
]>
<!-- XML header above -->
<!-- SGML header below-->
<!-- <!DOCTYPE article  PUBLIC "-//OASIS//DTD DocBook V4.1//EN"> -->

<book lang="en">
 <title>Fityk - User's Manual</title> 
 <bookinfo> 
  <date>2006-01-19</date>
  <author> 
   <firstname>Marcin</firstname> <surname>Wojdyr</surname>
  </author> 
 </bookinfo>

 <chapter> 
  <title>Introduction</title> 
  <section>
   <title>What is the program for?</title>
   <para>
    <application>Fityk</application> is a program 
    for nonlinear fitting of analytical functions (especially peak-shaped) 
    to data (usually experimental data). The shortest description:
    peak fitting software. There are also people using it only
    to display data or to remove baseline from data.
   </para>
   <para>
    It is reported to be used in crystallography, 
    chromatography, photoluminescence, infrared and Raman spectroscopy
    and other fields. Although author is ignorant about all these experimental
    methods but powder diffraction, 
    he would like to make it useful for as many people as possible.
   </para>
   <para>
    <application>Fityk</application> offers various nonlinear fitting methods, 
    easy background subtracting and other dataset manipulations, 
    easy placement of peaks and changing peak parameters, 
    support for analyzing series of datasets,
    automation of common tasks with scripts, and much more. 
    The main advantage of the program is a flexibility - parameters
    of peaks can be arbitrarily binded with each other, 
    eg. width of the peak can be an independent variable, 
    can be the same as the width of the other peak 
    or can be given by complicated - common for all peaks - formula.
   </para> 
   <para>
    <application>Fityk</application> is free software; you can redistribute 
    and modify it under the terms of <acronym>GPL</acronym>, version 2. 
    See <xref linkend="license"/> for details. 
    You can download the latest version of <application>fityk</application> from
    <ulink url="http://www.unipress.waw.pl/fityk">
     http://www.unipress.waw.pl/fityk 
    </ulink>.
    or
    <ulink url="http://fityk.sf.net/">
     http://fityk.sf.net 
    </ulink>.
    To contact author, visit the same page. 
   </para> 
  </section>

  <section>
   <title>How to read this manual</title>
   <para>
    After this introduction, read the <xref linkend="getstarted"/>.
    If you are using <acronym>GUI</acronym> you can look at 
    <ulink url="http://www.unipress.waw.pl/fityk/screenshots.html">
     screenshots-based tutorial at webpage 
    </ulink> 
    and postpone reading
    <xref linkend="CommandReference"/> until you need to write a script
    or understand better how the program works.
   </para>
  </section> 

  <section>
   <title><acronym>GUI</acronym> vs <acronym>CLI</acronym></title>
   <para>
    The program comes in two versions: <acronym>GUI</acronym> (Graphical User
    Interface) version - more comfortable for most users,
    and <acronym>CLI</acronym> (Command Line Interface) version 
    (named <command>cfityk</command> to differentiate, Unix only).
   </para>
   <para>
    If <acronym>CLI</acronym> version is compiled with 
    the <systemitem class="library">GNU Readline Library</systemitem>, 
    it enables command line editing and command history 
    like in <application>bash</application>.
    Especially useful is <keycap>TAB</keycap>-expanding [TODO: tab-expanding
    works only partially in this version]. 
    Data and curve fitted to data are visualized with 
    <application>gnuplot</application> program (if it is installed).
   </para>
   <para>
    <acronym>GUI</acronym> version is written using 
    <ulink url="http://www.wxwidgets.org">
     <systemitem class="library">wxWidgets</systemitem> 
    </ulink>
    library. 
    One of the main features of this library is portability. Program can be
    run on Unix species with <systemitem class="library">GTK+</systemitem>
    (it is developed on Linux) and on MS Windows. There are also people
    using it on MacOS X (have a look at fityk-users mailing list archives
    for details).
   </para>
  </section> 
 </chapter>


 <chapter id="getstarted">
  <title>Getting started</title>

  <section>
   <title>The minimal example</title>
   <para>
    Let us analyze a diffraction pattern of NaCl. Our goal is to determine the
    position of the center of the highest peak. It is needed for calculating
    pressure, under which the sample was measured, but the further processing
    does not matter in our example.
   </para>
   <para>
    Data file used in this example is distributed with the program and 
    can be found in <filename class="directory">samples</filename> directory. 
   </para>
   <para>
    First load data from file <filename>nacl01.dat</filename>. 
    You can do it by typing <userinput>@0 &lt; nacl01.dat</userinput> 
    in <acronym>CLI</acronym> version (or in <acronym>GUI</acronym> version 
    in the input box - at the bottom, just above the status bar). 
    In <acronym>GUI</acronym>, you can select
    <menuchoice>
     <guimenu>Data</guimenu><guimenuitem>Load File</guimenuitem>
    </menuchoice> 
    from menu and choose proper file, instead. 
   </para> 
   <para>
    If you use GUI, you can zoom in the biggest peak 
    using <mousebutton>left</mousebutton> mouse button on the auxiliary plot
    (the plot below main plot). 
    To zoom out, press <guiicon>View whole</guiicon> toolbar button.
    Other ways of zooming are described in <xref linkend="mouse"/>. 
    If you want the data to be drawn with 
    bigger points or line, or if you want to change color of line or background,
    press <mousebutton>right</mousebutton> mouse button on the main plot
    and use <guimenu>Data point size</guimenu> or <guimenu>Color</guimenu>
    menu from pop-up menu. To change color of data points, use right-hand
    panel.
   </para> 
   <para>
    Now all data points are active.
    Because only the biggest peak is of our interest, 
    the rest of points can be deactivated. 
    Type: <userinput> a = (23.0 &lt; x &lt; 26.0) </userinput>
    or change to <firstterm>range</firstterm> mode (press 
    <guiicon> Data-Range Mode </guiicon>
    button on toolbar) and select range 
    to be deactivated with <mousebutton>right</mousebutton> mouse button.
   </para>
   <para>
    We see that our data has no background, we
    would have to worry about, so now we only have to define peak with 
    reasonable initial values of peak's parameter and fit it to data. We will
    use Gaussian. 
    To see it's formula, type: <userinput>info Gaussian</userinput>
    or look for it in the documentation (in <xref linkend="flist"/>). 
    By the way, most of the commands can be abbreviated, 
    eg. you can type: <userinput>i Gaussian</userinput>. 
   </para>
   <para>
    To define peak, type: 
    <userinput>%p = Gaussian(~60000, ~24.6, ~0.2) -> F</userinput>
    or
    <userinput>%p = guess Gaussian</userinput>
    or select 
    <menuchoice><guilabel>Gaussian</guilabel></menuchoice> 
    from the list of functions on toolbar and press 
    <guiicon>
     auto-add 
     <!-- <inlinegraphic fileref="../src/img/clickadd.xpm"> -->
    </guiicon> 
    toolbar button.
    There are also other ways to add peak in <acronym>GUI</acronym>,
    try <firstterm>add-peak</firstterm> mode. 
    These mouse-driven ways give function a name like %_1, %_2, etc.
   </para>
   <para>
    Now let us fit the function. Type: <userinput>fit</userinput> 
    or select 
    <menuchoice>
     <guimenu>Fit</guimenu><guimenuitem>Run</guimenuitem>
    </menuchoice> 
    from menu (or press toolbar button). 
   </para>
   <para>
    To see peak parameters, type: <userinput> info+ %p</userinput>
    or (in GUI) move the cursor to the top of the peak 
    and try out context menu (right button), or use right-hand panel.
   </para>
   <para>
    That is all. To do the same second time, you can write all the commands 
    to file (you can do it now using command 
    <command>commands &gt; <replaceable>filename</replaceable></command>),
    and use it as script: 
    <userinput>commands &lt; nacl01.fit</userinput>
    or select 
    <menuchoice>
     <guimenu>Session</guimenu><guimenuitem>Execute script</guimenuitem>
    </menuchoice> 
    from menu, or run program with the name of the script: 
    <prompt>bash$ </prompt><userinput>fityk nacl01.fit</userinput>
   </para>
  </section> 

  <section>
   <title>Invoking fityk </title>
   <para>
    On startup, the program executes a script from the
    <filename>$HOME/.fityk/init</filename> file.
    Then the program handles files given as arguments on command line.
    If the filename has extension ".fit" or the file starts with "# Fityk"
    string, it is assumed to be a script and is executed.
    Otherwise,  it is assumed to be a data file and is loaded.
    There are also other parameters to CLI and GUI versions of the program.
    Option "-h" gives the full listing.
   </para>
  </section> 

  <section id="gui">
   <title>Graphical interface </title>
   <section>
    <title>Plots and other windows</title>
    <para>
     The window of <application>fityk</application> program consists 
     of (from the top): menu bar, 
     toolbar, main plot, auxiliary plot, output window, input field,
     status bar and of sidebar at right-hand side. 
     The input field allows to type and execute commands in
     similar way as it is done in <acronym>CLI</acronym> version. 
     The output window (which is configurable through pop-up menu)
     shows results. Actually all GUI commands are converted into text
     and visible in output window.
    </para>
    <para>
     The main plot can display
     data points, functions and/or the sum of all functions. Use pop-up
     menu (click <mousebutton>right</mousebutton> button on the plot) 
     to configure it. 
     Some properties of plot (eg. colors of data points) can be changed
     using the sidebar. 
    </para>
    <para>
     One of the most useful things which auxiliary plot can display 
     is the difference between data and the sum of functions. 
     The plot can be controlled by pop-up menu. I hope
     quick look at this menu and a minute of experiments will make
     all possibilities of the auxiliary plot clear.
    </para>
    <para>
     Sometimes it is useful to print effects of our fitting work. Hard copy
     will contain plots visible on the screen, scaled to fit the page. The only
     difference is that backgrounds of plots will be white (to not waste
     toner/ink). So it may be necessary to change color of axis or data to
     darker one.
    </para>
    <para>
     Configuration of GUI (visible windows, colors, etc.) can be saved using 
     <menuchoice>
      <guimenu>GUI</guimenu><guimenuitem>Save current config</guimenuitem>
     </menuchoice>. 
     Two different configurations can be saved, 
     what allows easy changing of colors
     for printing. On Unix platform, these configurations are stored 
     in file in user's home directory. 
     On Windows - they are stored in registry (perhaps in future they will 
     be also stored in file).
    </para>
   </section>

   <section id="mouse">
    <title>Mouse usage</title>
    <para>
     The usage of the mouse on menu, dialog windows, 
     input field and output window is
     intuitive, so the only topic described here is how to effectively
     operate mouse on plots.
    </para>
    <para>
     Let us start with the auxiliary plot. 
     <mousebutton>Right</mousebutton> button displays pop-up menu, 
     with <mousebutton>left</mousebutton> 
     button you can select range to be displayed - range on x axis. 
     Clicking with <mousebutton>middle</mousebutton> button (or with 
     <mousebutton>left</mousebutton> button and pressed <keycap>Shift</keycap>)
     will zoom it out and display all data. 
    </para>
    <para>
     On the main plot, meaning of the <mousebutton>left</mousebutton> and
     <mousebutton>right</mousebutton> mouse button depends on current 
     <firstterm>mode</firstterm>, that can be changed using toolbar or menu.  
     There are hints on the status bar.
     In normal mode, <mousebutton>left</mousebutton> button is used for
     zooming and <mousebutton>right</mousebutton> invokes pop-up menu.
     The same behaviour can be obtained in any mode by pressing
     <keycap>Ctrl</keycap> (or <keycap>Alt</keycap> or <keycap>Shift</keycap>).

     <mousebutton>Middle</mousebutton> 
     button can be used to select a rectangle that you want to zoom in. 
     If an operation has two steps, like rectangle zooming (first you 
     press button to select first corner, then you move mouse and release 
     button to select second corner of rectangle),
     you can cancel it by pressing another button when first one is pressed.
    </para>
   </section> 
  </section> 
 </chapter>


 <chapter id="CommandReference">
  <title>Reference </title>
  <section id="GeneralSyntax">
   <title>General syntax </title>
   <para>
    Basically, there is one command is in one line. 
    If, for some reasons, it is more comfortable to place more than one
    command in one line, they can be separated with semicolon (;). 
   </para>
   <para>
    Most of the commands can have arguments separated by comma (,), 
    eg. <command>delete %a, %b, %c</command>. 
   </para>
   <para>
    Most of the commands can be shortened: eg. you can type 
    <command>inf</command> or <command>in</command> or <command>i</command>
    instead of <command>info</command>.
   </para>
   <para>
    Symbol '#' starts a comment - everything from
    hash (#) to the end of the line is ignored.
   </para>
  </section>

  <section>
   <title>Data from experiment </title>
   <section id="DataLoad">
    <title>Storing and loading data </title>
    <para>
     Data are stored in files.  Unfortunately, there are various formats of
     files with data. The basic one is text file with every line 
     corresponding to one data point. The line should contain at least two
     numbers: x and y of point. It can also contain standard deviation of y
     coordinate.  Numbers can be separated by whitespace, commas, colons or
     semicolons. Some lines can contain comments or extra informations. If
     these lines have a hash (#) in first column, they are ignored. In other
     case, they are also ignored (unless they can be read as data point). 
     There are also other file types, that can be read: .rit, .cpi,
     Siemens-Bruker.raw and .mca. In future, the way the special file formats
     are handled will be changed (external library will be used for it,
     unfortunatelly this library does not exists yet).
    </para>
    <para>
     Points are loaded from files using command
    </para>
    <cmdsynopsis>
     <arg choice="plain"><replaceable>dataslot</replaceable></arg>
     <command>&lt;</command> 
     <arg choice="plain"><replaceable>filename</replaceable></arg> 
     <arg><replaceable>filetype</replaceable></arg>  
     <arg><replaceable>xcol</replaceable>,<replaceable>ycol</replaceable>
      <arg>,<replaceable>scol</replaceable></arg>
     </arg> 
    </cmdsynopsis>
    <para>
     where 
     <replaceable>dataslot</replaceable> 
     should be replaced with <userinput>@0</userinput>, 
     unless many datasets are to be used simultanously 
     (for details see: <xref linkend="multidata"/>),
     <replaceable>filetype</replaceable> can be omitted (at this moment,
     due to a small number of supported formats, the filetype can be
     detected automatically),
     <replaceable>xcol</replaceable>, <replaceable>ycol</replaceable>, 
     <replaceable>scol</replaceable>, 
     are unsigned integers. If the filename contains blank characters,
     semicolon or comma, it should be put inside of single
     quotation marks. If the file is in a text format (columns with numbers)
     it can be specified which column contains x, y and, optionally, std. dev.
     of y. 
    </para>
    <para>
     Command
     <cmdsynopsis>
      <arg choice="plain"><replaceable>dataslot</replaceable></arg>
      <command>&gt;</command> 
      <arg choice="plain"><replaceable>filename</replaceable></arg> 
     </cmdsynopsis>
     can export data to 3-column (x, y and standard deviation) ASCII file. 
     Only active points are being exported (see next chapter to learn about 
     active and inactive points).
    </para>
    <para>
     Some information about current data can be obtained using command:
    </para>
    <cmdsynopsis>
     <command>info</command>
     <arg choice="plain"><replaceable>dataslot</replaceable></arg>
    </cmdsynopsis>
   </section> 

   <section>
    <title>Active and inactive points</title>
    <para>
     We often have situation, that only part of data from file is interesting
     for us.  We should be able to exclude selected points from fitting and all
     computations. Every point can be either active or inactive.  
     It can be done with command <command>A=...</command> 
     (see <xref linkend="transform"/> for details)
     or with <link linkend="mouse">mouse-click in <acronym>GUI</acronym></link>.
     The idea of active and inactive points is simple: 
     only the active ones are subject to fitting and peak-finding, 
     inactive ones are neglected in these cases. 
    </para>
   </section> 

   <section>
    <title>Standard deviation or weight </title>
    <para>
     When fitting data, we assume that only y coordinate of data is subject to
     statistical errors in measurement. It is very common assumption. 
     To see how y standard deviation
     <inlinemediaobject>
      <imageobject><imagedata fileref="fitykhelp_img/sigma.png"/></imageobject>
      <textobject><phrase>sigma</phrase></textobject>
     </inlinemediaobject>  
     influences fitting (optimization), look at
     weighted sum of squared residuals formula in <xref linkend="nonlinear"/>. 
     We can also think about weights of points -
     every point has a weight assigned, that is equal 
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/w_1_sigma.png"/>
       </imageobject>
       <textobject>
        <phrase>w<subscript>i</subscript>=1/sigma^2</phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>
    </para>
    <para>
     Standard deviation of points can be 
     <link linkend="DataLoad">read from file</link> together with x and y
     coordinates. Otherwise, it is set to max(sqrt(y), 1.0), 
     Setting std. dev. as a square root of value is common 
     and has theoretical ground when y is the number of independent events.
     You can always change standard deviation, eg. make it equal for every
     point with command: <userinput>S=1</userinput>.
     See <xref linkend="transform"/> for details.
    </para>
   </section> 

   <section id="transform">  
    <title>Data transformations</title>
    <para>
     Every data point has four properties: x coordinate, y coordinate,
     standard deviation of y and active/inactive flag. Lower case 
     letters x, y, s, a stand for these properties before transformation,
     and upper case X, Y, S, A for the same properties after transformation.
     M stands for the number of points. 
     You can transform data using assignments.
     Command <userinput>Y=-y</userinput> will change the sign of y coordinate
     of every point. You can also apply transformation to selected points:
     <userinput>Y[3]=1.2</userinput> will change point with index 3 
     (which is 4th point, because first has index 0),
     and <userinput>Y[3...6]=1.2</userinput> will do the same for points with 
     indices 3, 4, 5, but not 6. <userinput>Y[2...]=1.2</userinput>
     will apply transformation to point with index 2 and all next points.
     You can guess what <userinput>Y[...6]=1.2</userinput> does.
     Most of operations are executed sequentially for points from the first 
     to the last one. n stands for the index of currently transformed point.
     The sequance of commands:
     <userinput>M=500; x=n/100; y=sin(x)</userinput>
     will generate the sinusoid dataset with 500 points. 
    </para>
    <para>
     Points are kept sorted according to x coordinate, so changing x coordinate
     of points will also change the order and indices of points.
    </para>
    <para>
     Expressions can contain 
     real numbers in normal or scientific format (eg. 1.23e5),
     constant <constant>pi</constant>,
     binary operators: +, -, *, /, ^,
     one argument functions:
     <function>sqrt</function>, 
     <function>exp</function>, 
     <function>log10</function>, 
     <function>ln</function>, 
     <function>sin</function>, 
     <function>cos</function>, 
     <function>tan</function>, 
     <function>atan</function>, 
     <function>asin</function>, 
     <function>acos</function>, 
     <function>abs</function>,
     <function>round</function> (rounds to the nearest integer),
     two arguments functions: 
     <function>min2</function>, 
     <function>max2</function>  
     (eg. <userinput>max2(3,5)</userinput> will give 5), 
     and ternary ?: operator: 
      <replaceable>condition</replaceable> ? 
      <replaceable>expression1</replaceable> : 
      <replaceable>expression2</replaceable>, which performs 
     <replaceable>expression1</replaceable> if condition is true 
     and <replaceable>expression2</replaceable> otherwise.
     Conditions can be built using boolean operators comparisions: 
     AND, OR, NOT, &gt;, &gt;=, &lt;, &lt;=, = (or ==), 
     != (or &lt;&gt;), TRUE, FALSE.
    </para>
    <para>
     Important note: all operations are performed on real numbers.
     Two numbers that differ less than epsilon=1e-9 
     ie. abs(a-b)&lt;epsilon, are considered equal. 
     Indices are also computed in real number domain, 
     and then rounded to nearest integer.
    </para>
    <para>
     Transformations can be joined with ampersand (&amp;), eg.
     <userinput>X=y&amp;Y=x</userinput> swaps axes.
    </para>
    <para>
     Before and after executing transformations, points are always 
     sorted according to x coordinate. You can change order of points
     using <command>order=<replaceable>t</replaceable></command>,
     where <replaceable>t</replaceable> is one of x, y, s, a, -x, -y, -s, -a.
     It only has a sense in sequence of transformations joined with &amp;,
     because after finishing transformation, points will be reordered again.
    </para>
    <para>
     Points can be deleted using following syntax:
     <command>delete[<replaceable>index-or-range</replaceable>]</command>
     or 
     <command>delete(<replaceable>condition</replaceable>)</command>
     and created simply by increasing value of M.
    </para>
    <para>
     There are two parametrized functions: spline and interpolate.
     The general syntax is: 
     <replaceable>parametrizedfunc</replaceable> 
     [<replaceable>param1</replaceable>, 
     <replaceable>param2</replaceable>](<replaceable>expression</replaceable>)
     eg. spline[22.1, 37.9, 48.1, 17.2, 93.0, 20.7](x) will give
     value of cubic spline interpolation through points (22.1, 37.9),
     (48.1, 17.2), ... in x.
     Function interpolation is similar, but give polyline interpolation.
     Spline function is used for manual background substraction in GUI.
    </para>
    <para>
     A few examples:
     <screen>     
     Y[1...] = Y[n-1] + y[n] # integrate

     x[...-1] = (x[n]+x[n+1])/2;  # reduces
     y[...-1] = y[n]+y[n+1];      # two times
     delete(n%2==1)               # number of points

     delete(not a) # delete inactive points

     X = 4*pi * sin(x/2*pi/180) / 1.54051 # changes x scale (2theta -> Q)
     </screen>     
    </para>
    <para>
     Introduced later in this manual
     <link linkend="variables">variables</link> also can be used in data
     transformations, eg. <userinput>Y=y/$foo</userinput>.
    </para>
   </section> 

   <section id="multidata">
    <title>Working with many datasets</title>
    <para>
     Let call a set of data that usually comes from one file - a 
     <firstterm>dataset</firstterm>. 
     All operations described above assume that only one dataset.
     If there are more datasets created, it must be explicitly
     written which dataset the command is applied to, eg.
     <userinput>M=500 in @0</userinput>. Datasets have numbers
     and are referenced by '@' with the number, eg. <userinput>@3</userinput>.
     <userinput>@*</userinput> means all datasets, 
     and <userinput>Y=y/10 in @*</userinput>
     will do what is expected to.
    </para>
    <para>
     Command
     <cmdsynopsis>
      <arg choice="plain">@+</arg>
      <command>&lt;</command> 
      <arg choice="plain"><replaceable>filename</replaceable></arg> 
      <arg><replaceable>filetype</replaceable></arg>  
      <arg><replaceable>xcol</replaceable>,<replaceable>ycol</replaceable>
       <arg>,<replaceable>scol</replaceable></arg>
      </arg> 
     </cmdsynopsis>
     will load dataset to new slot. Using @+ increases the number of datasets,
     and command <command>delete @<replaceable>n</replaceable></command>
     decreases it. It is also possible to duplicate dataset (command
     <command>@+ &lt; @<replaceable>n</replaceable></command>)
     or create new dataset as a sum of two or more existing ones 
     (command <command>@+ &lt; @<replaceable>n</replaceable> +
      @<replaceable>m</replaceable> + ...</command>).
    </para>
    <para>
     Each dataset has a separate <link linkend="sum">sum</link>, ie. a model
     that can be fitted to the data. It is explained in the next chapter.
    </para>
    <para>
     Each dataset has a title. It does not have to be unique.
     When loading file, a title is automatically created, either 
     using filename or it is read from the file (it depends on the format
     of the file).
     It is used for exporting data -- some file formats require it.
     Title can be changed using command 
     <command>
      @<replaceable>n</replaceable>.title=<replaceable>new-title</replaceable>
     </command>. 
     To see title of the dataset, 
     use <command>info @<replaceable>n</replaceable></command>.
    </para>
   </section> 
  </section> 


  <section id="sum">
   <title>Sum of fitted functions </title>
   <section id="sumintro">
    <title>Sum - Introduction</title>
    <para>
     The sum of functions S - curve that is fitted to data - is itself a
     function. The value of the whole sum is computed as a sum of functions,
     like Gaussians or polynomials, and can be given by formula:
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/sum_f.png"/>
       </imageobject>
       <textobject>
        <phrase>
         S = \sum<subscript>i</subscript> f<subscript>i</subscript>
        </phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>, 
     where f<subscript>i</subscript> is a function of x, and
     depends on a vector of parameters a. This vector contains all
     fitted parameters. 
     Because we often have the situation, that the error 
     in the x coordinate of data points can be modeled with function z(x; a),
     we introduce this term to sum:
     <informalequation>
      <mediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/sum_f_x_z.png"/>
       </imageobject>
       <textobject>
        <phrase>
         S(x;a) = \sum<subscript>i</subscript> f<subscript>i</subscript>
                                                                (x+z(x;a);a)
        </phrase>
       </textobject>
      </mediaobject>  
     </informalequation>
     where
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/z_x_a.png"/>
       </imageobject>
       <textobject>
        <phrase>
         z(x;a) = \sum<subscript>j</subscript> z<subscript>j</subscript>(x;a)
        </phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>
     . Note that the same z(x) is used in all functions.
    </para>
    <para>
     Now we will have a closer look at f<subscript>i</subscript> functions. 
     Every function f<subscript>i</subscript> has a type chosen from 
     function types available in the program. The same is true about
     functions z<subscript>i</subscript>.
     One of these types is the
     <emphasis>Gaussian</emphasis>. It has the following formula:
     <informalequation>
      <mediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/gauss_example.png"/>
       </imageobject>
       <textobject>
        <phrase>
         height exp[-ln(2) ((x-center)/hwhm)^2]
        </phrase>
       </textobject>
      </mediaobject>  
     </informalequation>
     There are three parameters of Gaussian. These parameters does not
     depend on x. There must be one <firstterm>variable</firstterm> 
     binded to each parameter.
    </para>
   </section>
   <section id="variables">
    <title>Variables</title>
    <para>
     Variables in Fityk have names prefixed with dollar ($).
     Variable is created by assigning a value to it, eg.
     <userinput>$foo=~5.3</userinput> 
     or <userinput>$c=3.1</userinput>
     or <userinput>$bar=5*sin($foo)</userinput>.
     <varname>$foo</varname> is here a so-called 
     <firstterm>simple variable</firstterm>. 
     It is created by assigning
     to it real number prefixed with ~. The `~' means that value
     assigned to the variable can be changed when fitting sum to data.
     For people familiar with optimization techniques: 
     the number of defined simple variables is the number of dimensions
     of space we are looking for optimum in.
     Variable <varname>$c</varname> 
     is actually a constant. <varname>$bar</varname> 
     depends on the value of <varname>$foo</varname>.
     When <varname>$foo</varname> changes, the value 
     of <varname>$bar</varname> also changes.
     Compound variables can be build using operators +, -, *, /, ^
     and functions 
     <function>sqrt</function>, 
     <function>exp</function>, 
     <function>log10</function>, 
     <function>ln</function>, 
     <function>sin</function>, 
     <function>cos</function>, 
     <function>tan</function>, 
     <function>atan</function>, 
     <function>asin</function>, 
     <function>acos</function>. 
    </para>
    <para>
     Every simple parameter has a value and, optionally, domain.  
     Domain is used only by fitting algorithms, 
     which need to randomly initialize or change variables. 
     Genetic Algorithms are a good example.
     [TODO: setting domain is not implemented at this moment, but will
     be added soon]
    </para>
    <para>
     Variables can be used in data tranformations. 
     Also value of data expression
     can be used in variable definition, but it must be inside of braces,
     eg. <userinput>$bleh={M}</userinput> 
     or, to create simple variable: <userinput>$bleh=~{M}</userinput>.
    </para>
    <para>
     Sometimes it is useful to freeze variable, ie. to prevent it's
     changes in fitting. There is no special syntax for it, 
     but it can be done using data expressions in this way:
     <screen>
      $a = ~12.3 # $a is fittable
      $a = {$a}  # $a is not fittable
      $a = ~{$a}  # $a is fittable again
     </screen>
    </para>
    <para>
     It is also possible to define a variable as eg. 
     <userinput>$bleh=~9.1*exp(~2)</userinput>. In this case two simple
     variables (with values 9.1 and 2) will be created automatically. 
     Automatically created
     variables are named <varname>$_1</varname>, <varname>$_2</varname>, 
     <varname>$_3</varname>, etc.
    </para>
    <para>
     Variables can be deleted using command 
     <command>delete <replaceable>$variable</replaceable></command>.
    </para>
   </section>
   <section>
    <title>Function types and functions</title>
    <para>
     Let's go back to functions. Function types have names that start
     with upper case letter, eg. Linear or Voigt. Functions 
     (ie. function instances) have names prefixed with percent,
     eg. %func. Every function has a type and variables binded to its
     parameters. 
    </para>
    <para>
     To see list of available function types, use command 
     <command>info types</command>. 
     You can also use command
     <command>info <replaceable>typename</replaceable></command>, 
     eg. <userinput>info Pearson7</userinput> to see parameter names,
     default values and formula.
    </para>
    <para>
     Function can be created by giving type and a proper
     number of comma-separated variables in brackets, eg:
     <userinput>%f = Gaussian(~66254., ~24.7, ~0.264)</userinput>
     or
     <userinput>%f = Gaussian(~66254., $ctr, $b+$c)</userinput>.
     Every expression, which is valid on the right hand side of variable
     assignment, can be put as a variable.
     If it is not just a name of a variable, an automatic variable is created.
     In the last example two variables are created (value 66354 and the sum).
    </para>
    <para>
     The second way is to give named parameters of function, in any order, eg.
     <userinput>%f = Gaussian(height=~66254., hwhm=~0.264, center=~24.7)
     </userinput>
     Function types can can have specified default values for
     some parameters, so this assignment is also valid:
     <userinput>
     %f = Pearson7(height=~66254., center=~24.7, fwhm=~0.264)
     </userinput>,
     although shape parameter of Pearson7 is not given.
    </para>
    <para>
     A deep copy of function (ie. all variables it dependends on
     are copied) can be made using command 
     <command>
      <replaceable>%function</replaceable>
      =copy(<replaceable>%anotherfunction</replaceable>)
     </command>
    </para>
    <para>
     Functions can be also created with command <command>guess</command>,
     as described in <xref linkend="guess"/>.
    </para>
    <para>
     You can change variable binded to any of function parameters
     in this way:
     <screen>
      =-> %f = Pearson7(height=~66254., center=~24.7, fwhm=~0.264)
      New function %f was created.
      =-> %f[center]=~24.8
      =-> $h = ~66254
      =-> %f[height]=$h
      =-> info %f
      %f = Pearson7($h, $_5, $_3, $_4)
      =-> $h = ~60000 # variables are kept by name, so this also changes %f
      =-> %p1[center] = %p2[center] + 3 # keep fixed distance between %p1 and %p2
     </screen>
    </para>
    <para>
     Functions can be deleted using command 
     <command>delete <replaceable>%function</replaceable></command>.
    </para>
   </section> 
   <section>
    <title>Speed of computations</title>
    <para>
     With default settings, value of every function is calculated
     in every point. Functions like Gaussian often have non-neglectible
     value only in small fraction of all points. To speed up calculation,
     set option
     <parameter class="option">cut-function-level</parameter> 
     to non-zero value. Note, that some functions may not support
     this optimization at all, and for other approximations are used
     and the exact value of cut-off level can differ.
    </para>
   </section> 
   <section>
    <title>Sum, F and Z</title>
    <para>
     As it was already written, each dataset has a separate sum. ie. a model
     that can be fitted to the data. 
     It can be seen in <link linkend="sumintro">formula above</link>,
     that the sum consists of functions f<subscript>i</subscript> 
     and z<subscript>i</subscript>. Each dataset has two sets named F and Z.
     They contain names of functions.
     Sum is constructed by telling which functions are in F and which in Z.
    </para>
    <para>
     In many cases Z can be forgotten. Then fitted curve is a sum of all
     functions in F. The functions can be listed with command 
     <command>info F</command>.
    </para>
    <para>
     Command 
     <command><replaceable>%function</replaceable> -&gt; F</command>
     puts <replaceable>%function</replaceable> into F,
     command 
     <command><replaceable>%function</replaceable> -&gt; Z</command>
     puts <replaceable>%function</replaceable> into Z,
     and command 
     <command><replaceable>%function</replaceable> -&gt; N</command>
     removes <replaceable>%function</replaceable> from F or Z.
     If there is more than one dataset, F, Z and N must be prefixed
     with dataset number, eg.
     <command>
      <replaceable>%function</replaceable> -&gt; <replaceable>@1</replaceable>.F
     </command>
     or
     <command>
      <replaceable>%function</replaceable> -&gt; <replaceable>@0</replaceable>.N
     </command>.
     Following syntax is also valid:
     <screen>
  # create and add funtion to F
  %g = Gaussian(height=~66254., hwhm=~0.264, center=~24.7) -> @0.F
  # create automatically named funtion and add it to F
  Gaussian(height=~66254., hwhm=~0.264, center=~24.7) -> @0.F
  # clear F
  @0.F = 0
  # clear F and put three functions in it
  @0.F = %a, %b, %c
  # make @1.F the exact (shallow) copy of @0.F
  @1.F = @0.F
  # make @1.F a deep copy of @0.F (it means all functions and variables
  # are duplicated).
  @1.F = copy(@0.F) </screen>
    </para>
    <para>
     Sum can be exported as data points (.dat), mathematic formula (.formula)
     or peak parameters (.peaks) using command:
     <command>F &gt; <replaceable>filename</replaceable></command>, 
     where <replaceable>filename</replaceable> have one of extensions
     listed above.
    </para>
    <para>
     It is often required to keep width or shape of peaks constant
     for all peaks in dataset. To change variables binded to parameters
     with given name of all functions in F, use command:
     <command>
      F[<replaceable>param</replaceable>]=<replaceable>variable</replaceable>
     </command>. Examples:
     <screen>
  F[hwhm]=$foo # hwhm's of all functions in F that have parameter hwhm will be 
               # equal $foo. (hwhm means here half-width-at-half-maximum)
  F[shape]=%_1[shape]  # variable binded to shape of peak %_1 is binded
                       # also to shapes of all functions in F
  F[hwhm]=~0.2  # For every function in F a new variable is created and binded 
                # to parameter hwhm. All these parameters are independent. </screen>
    </para>
   </section> 
   <section id="guess">
    <title>Guessing peak location </title>
    <para>
     It is possible to guess peak location and add it to F with command:
     <command>
      <replaceable>%name</replaceable> =
      guess <replaceable>PeakType</replaceable>
      [<replaceable>x1</replaceable>:<replaceable>x2</replaceable>]
      in @<replaceable>n</replaceable>
     </command>, 
     eg. <userinput>guess Gaussian [22.1:30.5] in @0</userinput>.
     If the range is omitted, the whole dataset will be searched.
     Name of function is optional.
    </para>
    <para>
     Fityk offers only primitive algorithm for peak-detection. 
     It looks for highest point in given range, and than tries to find out 
     width of peak. 
    </para>
    <para>
     If the highest point is found near the boundary
     of the given range, it is very probable that it is not the peak top,
     and, if <link linkend="settings">the option</link> 
     <parameter class="option">can-cancel-guess</parameter> 
     is set true, the guess is canceled.
    </para>
    <para>
     There are two real-number options related to <command>guess</command>: 
     <parameter class="option">height-correction</parameter> and 
     <parameter class="option">width-correction</parameter>. 
     Default value of them is 1.
     The guessed height and width are multiplied by the values of these
     options respectively.
    </para>
   </section> 
   <section>
    <title>Displaying informations </title>
    <para>
     If you are using GUI, most of informations can be displayed 
     with mouse clicks. Otherwise, you can use <command>info</command>
     command. Using <command>info+</command> instead of <command>info</command>
     sometimes displays more datailed informations.
     Command 
     <command>info peaks <replaceable>range</replaceable></command>
     will show, where the <command>guess</command> command would find the peak.
     <command>info functions</command> lists all defined functions,
     and <command>info variables</command> - all variables.
     <command>info @<replaceable>n</replaceable>.F</command> 
     and <command>info @<replaceable>n</replaceable>.Z</command> show 
     informations about F and Z, 
     <command>info @<replaceable>n</replaceable>.formula</command>
     shows mathematic formula of fitted function,
     and 
     <command>
      info @<replaceable>n</replaceable>.dF(<replaceable>x</replaceable>)
     </command>
     compares symbolic and numeric derivatives in <replaceable>x</replaceable>
     (useful only for debugging).
    </para>
   </section> 
  </section>

  <section>
   <title>Fitting </title>
   <section id="nonlinear">
    <title>Nonlinear optimization </title>
    <para>
     This is the core. We have a set of observations (data points), 
     and we want to fit a <firstterm>model</firstterm> (sum of functions), 
     that depends on adjustable parameters, to observations. 
     Let me quote <citetitle pubwork="book">Numerical Recipes</citetitle>, 
     chapter 15.0, page 656 (if you do not know the book, visit 
     <ulink url="http://www.nr.com">http://www.nr.com </ulink>):
    </para>
    <blockquote>
     <para>
      The basic approach in all cases is usually the same: You choose or design
      a figure-of-merit function (merit function, for short) that measures the
      agreement between the data and the model with a particular choice of
      parameters. The merit function is conventionally arranged so that small
      values represent close agreement. The parameters of the model are then
      adjusted to achieve a minimum in the merit function, yielding best-fit
      parameters.  The adjustment process is thus a problem in minimization in
      many dimensions.  [...] however, there exist special, more
      efficient, methods that are specific to modeling, and we will discuss
      these in this chapter. There are important issues that go beyond the mere
      finding of best-fit parameters. Data are generally not exact. They are
      subject to measurement errors (called noise in the context of
      signal-processing). Thus, typical data never exactly fit the model that
      is being used, even when that model is correct. We need the means to
      assess whether or not the model is appropriate, that is, we need to test
      the goodness-of-fit against some useful statistical standard. We usually
      also need to know the accuracy with which parameters are determined by
      the data set.  In other words, we need to know the likely errors of the
      best-fit parameters. Finally, it is not uncommon in fitting data to
      discover that the merit function is not unimodal, with a single minimum.
      In some cases, we may be interested in global rather than local
      questions. Not, "how good is this fit?" but rather, "how
      sure am I that there is not a very much better fit in some corner of
      parameter space?"
     </para>
    </blockquote>
    <para>
     Our function of merit is <acronym>WSSR</acronym> - weighted sum of
     squared residuals, called also chi-square:
     <informalequation>
      <mediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/chi2.png"/>
       </imageobject>
       <textobject>
        <phrase>
         chi<superscript>2</superscript> 
         = sum<subscript>i=1</subscript><superscript>N</superscript>
         [(y<subscript>i</subscript> - y(x<subscript>i</subscript>;a))
         /sigma<subscript>i</subscript>]<superscript>2</superscript>
         = sum<subscript>i=1</subscript><superscript>N</superscript>
         w<superscript>i</superscript>
         [y<subscript>i</subscript> - y(x<subscript>i</subscript>;a)]
         <superscript>2</superscript>
        </phrase>
       </textobject>
      </mediaobject>  
     </informalequation>
     Weights can be are based on standard deviations, 
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/w_1_sigma.png"/>
       </imageobject>
       <textobject>
        <phrase>w<subscript>i</subscript>=1/sigma^2</phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>.
     You can learn why squares of residuals are
     minimized eg. from chapter 15.1 of 
     <citetitle pubwork="book">Numerical Recipes</citetitle>. So we
     are looking for a global minimum of chi<superscript>2</superscript>. 
     This large field of numerical research - looking for minimum or maximum -
     is usually called optimization; it is non-linear and global optimization. 
     <application>Fityk</application> implements
     three very different optimization methods. All are well-known and
     described in many book. 
    </para>
   </section>

   <section>
    <title>Fitting related commands </title>
    <para>
     To fit sum to data, use command
     <cmdsynopsis>
      <command>fit</command> 
      <arg>+</arg> 
      <arg><replaceable>number-of-iterations</replaceable></arg> 
      <arg>in <replaceable>@n, ...</replaceable></arg> 
     </cmdsynopsis>
     Plus (+) means that fitting method is not initialized. It is used
     to continue previous fitting. 

     All non-linear fitting methods are iterative. 
     <replaceable>number-of-iterations</replaceable> 
     is the maximum number of iterations. There are also other 
     stopping criteria, so the number of executed iterations can be smaller.
    </para>
    <para>
     Fitting methods can be set using set command:
     <command>set fitting-method = <replaceable>method</replaceable></command>,
     where method is one of: Levenberg-Marquardt, Nelder-Mead-simplex,
     Genetic-Algorithms.
    </para>
    <para>
     <note>
      <para>
       The rest of this chapter is outdated,
       At this moment default settings of fitting methods can't be changed.
       It will be fixed as soon as possible.
      </para>
     </note>
    </para>
    <para>
     All non-linear fitting methods are iterative, and there are two common
     stopping criteria. The first is the number of iterations. 
     If it is not specified with command, value of option 
     <parameter class="option">default-max-iterations</parameter> is used.  
     And the second is the number of evaluations of objective function 
     (<acronym>WSSR</acronym>), specified by value of option 
     <parameter class="option">max-wssr-evaluations</parameter>. 
     It is approximately proportional to time of computations, because most of
     time in fitting process is taken by evaluating <acronym>WSSR</acronym>. 
     There are also other criteria, different for each method. 
     Note that values of all options, even those common for
     all methods, are set separately for every method. 
    </para>
    <para>
     If you give too small <replaceable>n</replaceable> 
     to <command>f.run</command> command, and fit is stopped because of
     it, not because of convergence, it makes sense to use 
     <command>f.continue</command> command to process further iterations. 
     [TODO: how to stop fit interactively] 
    </para>
    <para>
     When fit is running, each iteration outputs some informations. If they are
     scrolling too fast, you can reduce it <replaceable>n</replaceable> times 
     by assigning <replaceable>n</replaceable> 
     to <parameter class="option">output-one-of</parameter> option. 
    </para>
    <para>
     Setting <userinput>o.set autoplot = on-fit-iteration</userinput>
     will draw a plot after every iteration, to visualize progress. 
     (see <link linkend="autoplot">
      <parameter class="option">autoplot</parameter></link>)
    </para>
    <para>
     Command
     <footnote><para>
       Syntax of this command will be changed, other
       error estimates or measures of goodness-of-fit will be added.
     </para></footnote>
     :
     <cmdsynopsis>
      <command>f.info</command> <group><arg>*</arg><arg>**</arg></group> 
     </cmdsynopsis>
     can be used to display <acronym>WSSR</acronym>, 
     symmetric errors and variance-covariance matrix.
    </para>
    <para>
     Available methods can be mixed together, eg. it is
     sensible to obtain initial parameter estimates using simplex method,
     and than fit it using Levenberg-Marquard method. 
     Command <command>s.history</command> can
     be useful for trying various methods with different options and/or
     initial parameters and choosing the best solution.
    </para>
    <para>
     Some fitting methods are using random number generator. In some situations
     one may want to have repeatable and predictable results of fitting, eg.
     to make a presentation. Seed for a new sequence of pseudo-random
     numbers is set at the beginning of fitting initialization 
     (when <command>f.run</command> is called). If value of 
     <parameter class="option">pseudo-random-seed</parameter> 
     option is set to -1, the seed is based on system time and sequence of
     pseudo-random numbers is every time different. In other case, if
     <parameter class="option">pseudo-random-seed</parameter> option has
     a non-negative value, this value is used as a seed. Remember, that like
     all other options, value of 
     <parameter class="option">pseudo-random-seed</parameter> is independent 
     for each fitting method.
    </para>
   </section>

   <section>
    <title>Levenberg-Marquardt </title>
    <para>
     <note>
      <para>
       The rest of this chapter is outdated,
       At this moment default settings of fitting methods can't be changed.
       It will be fixed as soon as possible.
      </para>
     </note>
    </para>
    <para>
     It is a standard of nonlinear least-squares routines. It involves
     computing first derivatives of functions. For description of L-M method
     see <citetitle pubwork="book">Numerical Recipes</citetitle>, chapter 15.5 
     or Siegmund Brandt <citetitle pubwork="book">Data Analysis</citetitle>,
     chapter 10.15 (I've read the Polish translation of the second). 
     In a few words: it combines
     inverse-Hessian method (called Gauss-Newton method?) with steepest descent
     method by introducing lambda factor. When lambda is equal 0, the method is
     equivalent to inverse-Hessian method. When lambda increases, the shift
     vector is rotated toward the direction of steepest descent and the length
     of the shift vector decreases. (The shift vector is a vector that is added
     to the parameter vector.) If the better fit is found in iteration, lambda
     is decreased - it is divided by value of 
     <parameter class="option">lambda-down-factor</parameter> option 
     (default: 10). Otherwise, lambda is multiplied by value of 
     <parameter class="option">lambda-up-factor</parameter> (default: 10). 
     You can also change a value of 
     <parameter class="option">lambda-starting-value</parameter> option. 
    </para>
    <para>
     Marquardt method has one stopping criterium apart from common stopping
     criteria. If it happens two times in sequence, that relative 
     progress in value of objective function (<acronym>WSSR</acronym>) 
     is smaller then value of 
     <parameter class="option">stop-rel-change</parameter> option,
     fit is considered to be converged and is stopped. </para>
    <para>
     L-M method finds a minimum quickly. The question is, if it is the
     global minimum.  It can be a good idea to add a small random vector to
     the vector of parameters and try again. This small shift vector is added, 
     when value of <parameter class="option">shake-before</parameter> option 
     is positive (by default it is 0). Value of every parameter's shift 
     is independent and randomly drawn from distribution of type specified by
     value of <parameter class="option">shake-type</parameter> option 
     (see <link linkend="distribtype">option 
      <parameter class="option">distrib-type</parameter></link>)
     in simplex method). The expected value of parameter shift is
     directly proportional to both value of 
     <parameter class="option">shake-before</parameter> option and width of
     parameter's domain.
    </para>
   </section>

   <section>
    <title>Nelder-Mead downhill simplex method </title>
    <para>
     This time I am quoting chapter 4.8.3, p. 86 of Peter Gans
     <citetitle>
      Data Fitting in the Chemical Sciences by the Method of Least Squares 
     </citetitle> 
    </para>
    <blockquote>
     <para>
      A simplex is a geometrical entity that has n+1 vertices corresponding to
      variations in n parameters.  For two parameters the simplex is a
      triangle, for three parameters the simplex is a tetrahedron and so forth.
      The value of the objective function is calculated at each of the
      vertices. An iteration consists of the following process. Locate the
      vertex with the highest value of the objective function and replace this
      vertex by one lying on the line between it and the centroid of the other
      vertices. Four possible replacements can be considered, which I call
      contraction, short reflection, reflection and expansion.[...]
     </para>
     <para>
      It starts with an arbitrary simplex. Neither the shape nor position of
      this are critically important, except insofar as it may determine which
      one of a set of multiple minima will be reached. The simplex than expands
      and contracts as required in order to locate a valley if one exists. Then
      the size and shape of the simplex is adjusted so that progress may be
      made towards the minimum. Note particularly that if a pair of
      parameters are highly correlated, <emphasis>both</emphasis> will be
      simultaneously adjusted in about the correct proportion, as the shape of
      the simplex is adapted to the local contours.[...]
     </para>
     <para>
      Unfortunately it does not provide estimates of the parameter errors, etc.
      It is therefore to be recommended as a method for obtaining initial
      parameter estimates that can be used in the standard least squares
      method.
     </para>
    </blockquote>
    <para>
     This method is also described in previously mentioned 
     <citetitle>Numerical Recipes</citetitle> (chapter 10.4) 
     and <citetitle>Data Analysis</citetitle> (chapter 10.8).
    </para>
    <para>
     <note>
      <para>
       The rest of this chapter is outdated,
       At this moment default settings of fitting methods can't be changed.
       It will be fixed as soon as possible.
      </para>
     </note>
    </para>
    <para>
     There are a few options for tuning this method.
     One of those is a stopping criterium 
     <parameter class="option">min-fract-range</parameter>. If value of
     expression 2(M-m)/(M+m), where M and m are values of worst and best
     vertices respectively (values of objective functions of vertices, to be
     precise), is smaller then value of 
     <parameter class="option">min-fract-range</parameter> option, fitting is
     stopped. In other words, it is stopped if all vertices are at almost the
     same level.
    </para>
    <para id="distribtype">
     The rest of options is related to initialization of simplex. Before
     starting iterations, we have to chose set of points in space of
     parameters, called vertices.  Unless option 
     <parameter class="option">move-all</parameter> is set, one of these
     points will be the current point - values that parameters have at this
     moment. All but this one are drawn as follows: each parameter of each
     vertex is drawn separately. It is drawn from distribution, that has center
     in center of domain of parameter, and width proportional to both width of
     domain and value of <parameter class="option">move-multiplier</parameter> 
     parameter.  Distribution type can be set using option 
     <parameter class="option">distrib-type</parameter> as one
     of: uniform, Gaussian, Lorentzian and bound. The last one causes value of
     parameter to be either greatest or smallest value in domain of parameter 
     - one of two bounds of domain 
     (assuming that <parameter class="option">move-multiplier</parameter>
     is equal 1).
    </para>
   </section>

   <section>
    <title>Genetic Algorithms</title>
    <para>
     [TODO]
    </para>
   </section>
  </section> 

  <section id="settings">
   <title>Settings </title>
   <para>
    This chapter is not about GUI settings (things like colors,
    fonts, etc.).
   </para>
   <para>
    Command <command>info set</command> shows syntax of the set command
    and lists all possible options.
   </para>
   <para>
    [TODO: this chapter should be expanded...] 
   </para>
  </section> 

  <section>
   <title>Other commands </title>
   <section>
    <title>plot: viewing data</title>
    <para>
     In GUI version there is hardly ever need to use this command directly.
    </para>
    <para>
     Command <command>plot</command> controls visualization of data 
     and the sum.
     It is used to plot given area - in <acronym>GUI</acronym> it is plotted
     in program's main window, in <acronym>CLI</acronym> popular program 
     <application>gnuplot</application> is used, if available. 
     <cmdsynopsis>
      <command>plot</command> 
      <arg><replaceable>xrange</replaceable>
       <arg><replaceable>yrange</replaceable></arg>
      </arg> 
     </cmdsynopsis>
     <replaceable>xrange</replaceable> and <replaceable>yrange</replaceable>
     have one of two following syntaxes:
     <cmdsynopsis>
      <arg choice="req">[</arg> <arg><replaceable>min</replaceable></arg>
      <arg choice="plain">:</arg>
      <arg><replaceable>max</replaceable></arg> <arg choice="req">]</arg>
     </cmdsynopsis>
     <cmdsynopsis>
      <arg choice="plain">.</arg>
     </cmdsynopsis>
     The second is just a dot (.), and it remains appropriate range not changed.
    </para>
    <para>
     Examples:
     <screen>
   plot [20.4:50] [10:20] #plot will show x from 20.4 to 50 and y from 10 to 20

   plot [20.4:] # x from 20.4 to the end, 
                # y range will be fitted to contain all data

   plot . [:10] # x range will not be changed, y from the lowest point to 10 
   plot [:] [:] # all data will be showed   
   plot         # all data will be showed   
   plot . .     # nothing changes
     </screen>
    </para>

    <para id="autoplot">
     Value of option <parameter class="option">autoplot</parameter> changes 
     automatic plotting behaviour. By default, plot is refreshed automatically 
     after changing the data or the sum of functions.  
     It is also possible to visualize every iteration of fitting method by
     replotting peaks after every iteration.
    </para>
   </section>
   <section>
    <title>info: show informations</title>
    <para>
     First, there is an option 
     <parameter class="option">verbosity</parameter>
     (not related to command <command>info</command>)
     which decides about amount of messages displayed when executing commands.
    </para>
    <para>
     If you are using GUI, most of informations can be displayed 
     with mouse clicks. Otherwise, you can use <command>info</command>
     command. Using <command>info+</command> instead of <command>info</command>
     sometimes displays more datailed informations.
    </para>
    <para>
     [TODO: list of all info arguments]
    </para>
   </section>
   <section>
    <title>commands, dump, sleep, reset, quit</title>
    <para>
     All commands given during program execution are stored in memory.
     They can be listed using command:
     <command>
      commands [<replaceable>n</replaceable>:<replaceable>m</replaceable>]
     </command> 
     or written to file: 
     <command>
      commands [<replaceable>n</replaceable>:<replaceable>m</replaceable>]
      &gt; <replaceable>filename</replaceable>
     </command>.
    </para>
    <para>
     To log commands to file, when they are executed, use:
     <command>
      commands &gt; <replaceable>filename</replaceable>
     </command> or, to log also output:
     <command>
      commands+ &gt; <replaceable>filename</replaceable>
     </command>.
     To stop logging, use: <command> commands &gt; /dev/null </command>.
    </para>
    <para>
     Scripts can be executed using command:
     <command>
      commands &lt; <replaceable>filename</replaceable>
     </command>.
    </para>
    <para>
     There is also a command
     <command>dump &gt; <replaceable>filename</replaceable></command>,
     [TODO] which is not working at this moment.
    </para>
    <para>
     Command <command>sleep <replaceable>sec</replaceable></command> 
     makes program waiting <replaceable>sec</replaceable> seconds,
     doing nothing. 
    </para>
    <para>
     Command <command>quit</command> works as expected.
    </para>
    <para>
     If option <parameter class="option">exit-on-warning</parameter> 
     is set, any warning will close the program. It ensures, that no warnings
     can be overlooked.
    </para>
   </section> 
  </section> 
 </chapter>


 <chapter id="useandextend">
  <title>Using and extending </title>
  <section id="usecases">
   <title>Use cases</title>
   <para>
    [TODO]
   </para>
  </section> 
  <section id="extensions">
   <title>Extensions</title>
   <section>
    <title>How to add own built-in function</title>
    <para>
     To add built-in function, you have to change the source of the program
     and compile it. Users who want to do it should be able to compile
     the program from source and know basics of C, C++ or another programming
     language.
    </para>
    <para>
     The description here is not complete. You something is not clear,
     you can always send me e-mail, etc.
    </para>
    <para>
     "fp" you can see in fityk source means a real (floating point) number 
     (typedef double fp).
    </para>
    <para>
     The name of your function should start with uppercase letter and contain
     only letters and digits.  Let's add function Foo with formula: 
     Foo(height, center, hwhm) = height/(1+((x-center)/hwhm)^2).
     C++ class representing Foo will be named FuncFoo.
    </para>
    <para>
     In src/func.cpp find a list of functions: 
     <screen>     
       ...
       FACTORY_FUNC(Polynomial6)
       FACTORY_FUNC(Gaussian)
       ...
      </screen>     
     and add:
     <screen>     
       FACTORY_FUNC(Foo)
      </screen>     

     Then find another list:
     <screen>     
       ...
       FuncPolynomial6::formula,
       FuncGaussian::formula,
       ...
      </screen>     
     and add line
     <screen>     
      FuncFoo::formula,
     </screen>     
     Note that in the second list
     all items but the last one are followed by comma.
    </para>
    <para>
     Write the function formula in the same file in this way:
     <screen>     
      const char *FuncFoo::formula
      = "Foo(height, center, hwhm) = height/(1+((x-center)/hwhm)^2)";
     </screen>     
     For built-in functions, only the left hand side of the formula is parsed.
     I.e. expression "Foo(height, center, hwhm)" is analysed by the program
     and has to have a valid syntax. 
     Parameter names: "height", "area", "center", "fwhm" and "hwhm" 
     are recognized.
     hwhm is half width at half maxium, and fwhm is full width at half maxium.
     If you want to be able to add function with command guess, you must provide
     default values for all parameters with other names, e.g.:
     SplitPearson7(height, center, hwhm1=fwhm*0.5, hwhm2=fwhm*0.5, shape1=2, shape2=2). 
     Type "i+ types" for other examples. 
     Now syntax for giving default values is very limited. 
     It can be a real number 
     or one of the recognized parameter names (but hwhm) 
     or recognized parameter * real number.
    </para>
    <para>
     In file src/func.h start writting definition of your class:
     <screen>
      class FuncFoo : public Function
      {
          DECLARE_FUNC_OBLIGATORY_METHODS(Foo)
     </screen>
     If you want to make some calculations every time parameters of function
     are changed, you can do it in method do_precomputations.
     This possibility is provided for calculating calculating expressions,
     which does not depend on x. Write the declaration here:
     <screen>
     void do_precomputations(std::vector&lt;Variable*&gt; const &amp;variables);
     </screen>
     and provide proper definition of this method 
     in <filename>src/func.cpp</filename>.
    </para>
    <para>
     If you want to optimize calculation of your function by neglecting
     its value outside of give range 
     (see option <parameter class="option">cut-function-level</parameter> 
     in the program),
     you will need method:
     <screen>
      bool get_nonzero_range (fp level, fp &amp;left, fp &amp;right) const;
     </screen>
     This method takes the level, below which the value of the function
     can be approximated by zero, and should set left and right variable
     to proper values of x, 
     such that if x&lt;left or x&gt;right than |f(x)|&lt;level. 
     If the function sets left and right, it should return true.
    </para>
    <para>
     If your function does not have a "center" parameter, and there is a 
     center-like point, where you want the peak top to be drawn, write:
     <screen>
      bool has_center() const { return true; }
      fp center() const { return vv[1]; }
     </screen>
     In the second line, between return and semicolon, there is an expression
     for x coordinate of peak top; vv[0] is the first parameter of function,
     vv[1] is the second, etc.
    </para>
    <para>
     Finally close the definition of the class with:
     <screen>
      };
     </screen>
    </para>
    <para>
     Now come back to <filename>src/func.cpp</filename> and write, 
     how to calculate value of the function:
     <screen>
      FUNC_CALCULATE_VALUE_BEGIN(Foo)
          fp xa1a2 = (x - vv[1]) / vv[2];
          fp inv_denomin = 1. / (1 + xa1a2 * xa1a2);
      FUNC_CALCULATE_VALUE_END(vv[0] * inv_denomin)
     </screen>
     Expression at the end (i.e. vv[0]*inv_denomin) is the calculated value.
     xa1xa2 and inv_denomin are variables introduced to simplify
     expression. Note "fp" (you can also use "double") at the beginning
     and semicolon at the end of both lines. Meaning of vv was 
     already explained.

     Usually it is more difficult do calculate derivatives:

     <screen>
      FUNC_CALCULATE_VALUE_DERIV_BEGIN(Foo)
          fp xa1a2 = (x - vv[1]) / vv[2];
          fp inv_denomin = 1. / (1 + xa1a2 * xa1a2);
          dy_dv[0] = inv_denomin;
          fp dcenter = 2 * vv[0] * xa1a2 / vv[2] * inv_denomin * inv_denomin;
          dy_dv[1] = dcenter;
          dy_dv[2] = dcenter * xa1a2;
          dy_dx = -dcenter;
      FUNC_CALCULATE_VALUE_DERIV_END(vv[0] * inv_denomin)
     </screen>

     You must set derivatives 
     dy_dv[n] for n=0,1,...,(number of parameters of your function - 1)
     and dy_dx. In the last brackets there is a value of the function again.
    </para>
    <para>
     After compilation of the program check if the derivatives are calculated 
     correctly using command "info dF(x)", eg. i dF(30.1).
    </para>
    <para>
     Hope this helps.
     Don't hesistate to change this description or ask questions 
     if you have any.
    </para>
   </section>
  </section> 
 </chapter>

 <appendix id="flist">
  <title>List of functions</title>
  <para>
   The list of all functions can be obtained using 
   <userinput>i+ types</userinput>. Some formulae here have long parameter
   names (like "height", "center" and "hwhm") replaced with 
   a<subscript><replaceable>i</replaceable></subscript>.

   <equation id="gaussian">
    <title>Gaussian</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/gaussian.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Gaussian" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="gaussiana">
    <title>GaussianA</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/gaussiana.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info GaussianA" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="lorentzian">
    <title>Lorentzian</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/lorentzian.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Lorentzian" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="lorentziana">
    <title>LorentzianA</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/lorentziana.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info LorentzianA" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="pearson7">
    <title>Pearson VII (Pearson7)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/pearson7.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Pearson7" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="psvoigt">
    <title>Pseudo-Voigt (PseudoVoigt)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/pseudo_voigt.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info PseudoVoigt" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   Pseudo-Voigt is a name for sum of Gaussian and Lorentzian.
   a<subscript>3</subscript> parameters in Pearson VII and Pseudo-Voigt 
   are not related.
   <equation id="psvoigta">
    <title>Pseudo-Voigt-Area (PseudoVoigtA)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/pseudo_voigta.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info PseudoVoigtA" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="voigt">
    <title>Voigt</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/voigt.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Voigt" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   Voigt function is a convolution of Gaussian and Lorentzian functions.
   a<subscript>0</subscript> = heigth,
   a<subscript>1</subscript> = center,
   a<subscript>2</subscript> is proportional to the Gaussian width, and
   a<subscript>3</subscript> is proportional to the ratio of Lorentzian 
   and Gaussian widths. And t is just a variable of integration.  
   Voigt is computed according to R.J.Wells, 
   <citetitle pubwork="article">
    Rapid approximation to the Voigt/Faddeeva function and its derivatives
   </citetitle>, 
   Journal of Quantitative Spectroscopy &amp; Radiative Transfer 
   62 (1999) 29-48.
   (See also: http://personalpages.umist.ac.uk/staff/Bob.Wells/voigt.html). 
   Is the approximation exact enough for all possible uses of 
   <application>fityk</application> program? 
   <equation id="voigta">
    <title>VoigtA</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/voigta.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info VoigtA" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="emg">
    <title>Exponentially Modified Gaussian (EMG)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/emg.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info EMG" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="doniachs">
    <title>Doniach-Sunjic (DoniachSunjic)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/doniachs.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info DoniachSunjic" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation>
    <title>Polynomial5</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/polynom5.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Polynomial5" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
  </para>
 </appendix>

 <appendix id="license">
  <title>License</title>
  <para>
   <application>Fityk</application> is free software; you can redistribute
   and modify it under terms of GNU General Public License,
   version 2. There is no warranty. 
   <acronym>GPL</acronym> is one of most popular
   licenses, and it is worth reading, if you have not done it
   before. The program is copyrighted by author, and the license
   itself by <acronym>FSF</acronym>. 
   Text of the license is distributed with the program 
   in file <filename>COPYING</filename>.
  </para>
 </appendix> 

 <appendix>
  <title>About this manual </title>
  <para>
   This manual is written in DocBook (XML)
   and converted to other formats. All changes, improvements,
   fixes of mistakes, etc. are welcome. 
   The <filename>fitykhelp.xml</filename> file is
   distributed with program sources, and can be modified with any
   text editor. 
  </para>
 </appendix> 

 <bibliography> 
  <biblioentry> 
   <abbrev>1</abbrev>
   <authorgroup>
    <author>
     <surname>Press</surname>  <firstname>William</firstname>
    </author>
    <author>
     <surname>Teukolsky</surname> <firstname>Saul</firstname>
    </author>
    <author>
     <surname>Vetterling</surname> <firstname>William</firstname>
    </author>
    <author>
     <surname>Flannery</surname> <firstname>Brian</firstname>
    </author>
   </authorgroup>
   <title>Numerical Recipes in C</title>
   <address><otheraddr>http://www.nr.com</otheraddr></address>
  </biblioentry>
  <biblioentry> 
   <abbrev>2</abbrev>
   <author>
    <surname>Gans</surname> <firstname>Peter</firstname>
   </author>
   <title>
    Data Fitting in the Chemical Sciences by the Method of Least Squares
   </title>
   <publishername>John Wiley &amp; Sons</publishername>
   <pubdate>1992</pubdate>
  </biblioentry> 
  <biblioentry>
   <abbrev>3</abbrev>
   <author><firstname>Siegmund</firstname><surname>Brandt</surname></author>
   <title>Data Analysis</title>
   <publishername>Springer Verlag</publishername>
   <pubdate>1999</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>4</abbrev>
   <title>PeakFit 4.0 for Windows User's Manual</title>
   <publishername>AISN Software</publishername>
   <pubdate>1997</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>5</abbrev>
   <author>
    <firstname>Zbigniew</firstname><surname>Michalewicz</surname>
   </author>
   <title>Algorytmy genetyczne + struktury danych = programy ewolucyjne</title>
   <publishername>WNT</publishername>
   <pubdate>1996</pubdate>
  </biblioentry>
<!--
  <biblioentry>
   <abbrev>6</abbrev>
   <editor><firstname>R. A.</firstname><surname>Young</surname></editor>
   <title>The Rietveld Method</title>
   <publishername>Oxford University Press</publishername>
   <pubdate>1993</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>7</abbrev>
   <author><firstname>R. A.</firstname><surname>Young</surname></author>
   <title>User's Guide to Program DBWS-9807a</title>
   <pubdate>2000</pubdate>
  </biblioentry>
-->
 </bibliography>

</book>
<!-- vim: set ai sw=1 expandtab:  -->

